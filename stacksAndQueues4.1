class MaxStack:
    def __init__(self):
        self.stack = []         #main stack — holds all values in stack order (LIFO)
        self.max_stack = []     #stack to track max values

    def push(self, val): #Method to push a value onto the stack
        self.stack.append(val) #add value

        if not self.max_stack: #if stack is empty, this value becomes the max
            self.max_stack.append(val)
        else:
            current_max = self.max_stack[-1] #get current max (top of max_stack)
            self.max_stack.append(max(val,current_max)) #push new max (either val or current max)

    def pop(self):  #Method to pop (remove and return) the top value
        if not self.stack:
            raise Exception("Stack is empty!")

        self.max_stack.pop() #also pop from max_stack to keep it in sync
        return self.stack.pop() #pop from main stack and return the value

    def max(self):
        if not self.max_stack:
            raise Exception("Stack is empty!")

        return self.max_stack[-1] #return top of max_stack (current max)


    def print_stack(self):
        print("Current stack:", self.stack)
        print("Current max stack:", self.max_stack)
        if self.max_stack:
            print("Current max:", self.max())
        else:
            print("Stack is empty!")

    def is_empty(self):
        return len(self.stack) == 0




s = MaxStack()

s.push(2)
print("max after push(2): ", s.max())

s.push(1)
print("max after push(1): ", s.max())

s.push(5)
print("max after push(5): ", s.max())

s.push(3)
print("max after push(3): ", s.max())

print("popped:", s.pop())
s.print_stack()

print("popped:", s.pop())
s.print_stack()


print("popped: ", s.pop())
if not s.is_empty():
    print("max after pop(): ", s.max())
else:
    print("Stack is empty — no max!")

print("popped: ", s.pop())
if not s.is_empty():
    print("max after pop(): ", s.max())
else:
    print("Stack is empty — no max!")